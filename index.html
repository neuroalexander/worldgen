<!DOCTYPE html>
<html>
<head>
<title>Hit refresh</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    background-color: #f1f1f1;
		margin: 0;
		position: absolute;
    top:0;
    bottom: 0;
    left: 0;
    right: 0;
		padding: 0;
    width: 100%;
    height: 100%;
}
</style>
</head>
<body onload="startGame()">
<script>

const octaves = 20
const combinationmu = 1.9//Larger -> more higher octave components
const combinationsigma = 2.3 //Smaller -> faster reduction in octave plasticity
const micronoise = 0.002
const scale = 3
const edgedroprate = 0.45 + Math.random()*0.35 //Larger -> more peripheral water (more island-like)
const moisturediffuseness = 100 //Larger -> more diffuse spread of moisture
const latitudesigma = 0.3*edgedroprate//0.18
const waterlevel = 0.47;
const docheight = document.documentElement.clientHeight;
const docwidth = document.documentElement.clientWidth;
let objectsy = docheight/scale
let objectsx = docwidth/scale
const pixelheight = Math.ceil(docheight/objectsy)
const pixelwidth = Math.ceil(docwidth/objectsx)
let	points = [];
for (let y = 0; y < objectsy; y++) {
	points[y] = [];
	for (let x = 0; x < objectsx; x++) {
		points[y][x] = 0;
		}
	}
	
function component(height, width, y, x, elevation, moisture, latitude) {
    this.width = width;
    this.height = height;
		this.x = x;
    this.y = y; 
		this.elevation = elevation
		this.moisture = moisture
		this.latitude = latitude
		this.temp = 0
    this.colour = 'DarkRed'
    this.update = function(){
				this.colour = colourGet(this.elevation, this.moisture, this.latitude, this.temp, waterlevel)
        ctx = myGameArea.context;
        ctx.fillStyle = this.colour;
        ctx.fillRect(this.x*pixelwidth, this.y*pixelheight, this.width, this.height);
    }
}

function colourGet(elevation, moisture, latitude, temp, waterlevel) {
	let output = 0;
		let green = 0;
		let red = 0;
		let blue = 0;
		let brightness = 0;
		let logelevation = (Math.log10(elevation)+1 < 0 ? 0 : Math.log10(elevation)+1)
		let logmoisture = (Math.log10(moisture)+1 < 0 ? 0 : Math.log10(moisture)+1)
		let loglatitude = (Math.log10(latitude)+1 < 0 ? 0 : Math.log10(latitude)+1)
		let logtemp = (Math.log10(temp)+1 < 0 ? 0 : Math.log10(temp)+1)
		temp = 0.7*latitude + 0.3*(1-elevation)
		
		if (temp < 0.15 && moisture > 0.05) {
			if (elevation < 0.35) {return 'Teal'}
			else if (elevation < 0.38) {return 'DarkCyan'}
			else if (elevation < 0.41) {return 'LightSeaGreen'}
			else if (elevation < 0.43) {return 'MediumAquaMarine'}
			else if (elevation < 0.55) {return 'Gainsboro'}
			else if (elevation < 0.6) {return 'WhiteSmoke'}
			else if (elevation <= 1) {return 'AliceBlue'}
		}
		if (elevation < waterlevel-0.08) {return 'Teal'}
		else if (elevation < waterlevel-0.05) {return 'DarkCyan'}
		else if (elevation < waterlevel-0.02) {return 'LightSeaGreen'}
		else if (elevation < waterlevel) {return 'MediumAquaMarine'}
		else if (elevation < waterlevel+0.01) {return 'Khaki'}
		else if (elevation < 0.52) {output = [(0.9*0 + 0.1*(1-moisture)*255)*(1-0.5*latitude)*(1-temp/3), (0.9*100 + 0.1*temp*255)*(1-0.5*latitude + 0.5*moisture)*(1-temp/3), 0*(1-0.5*latitude*255)*(1-temp/3)]}//'DarkGreen'}
		else if (elevation < 0.56) {output = [(0.9*0 + 0.1*(1-moisture)*255)*(1-0.5*latitude)*(1-temp/3), (0.9*128 + 0.1*temp*255)*(1-0.5*latitude + 0.5*moisture)*(1-temp/3), 0*(1-0.5*latitude*255)*(1-temp/3)]}//'Green'}
		else if (elevation < 0.60) {output = [(0.9*34 + 0.1*(1-moisture)*255)*(1-0.5*latitude)*(1-temp/3), (0.9*139 + 0.1*temp*255)*(1-0.5*latitude + 0.5*moisture)*(1-temp/3), 34*(1-0.5*latitude*255)*(1-temp/3)]}//'ForestGreen'}
		else if (elevation < 0.65) {output = [(0.8*107 + 0.2*(1-latitude))*(1-temp/2), (0.8*142 + 0.1*(temp)*255 + 0.1*(moisture)*255)*(1-temp/2), 35*(1-temp/2)]}//'OliveDrab'}
		else if (elevation < 0.68) {output = [(0.8*85 + 0.2*(1-latitude))*(1-temp/2), (0.8*107 + 0.1*(temp)*255 + 0.1*(moisture)*255)*(1-temp/2), 47*(1-temp/2)]}//'DarkOliveGreen'}
		else if (elevation < 0.72) {output = [105, 105, 105]}//'DimGrey'}
		else if (elevation < 0.74) {output = [220, 220, 220]}//'Gainsboro'}
		else if (elevation < 0.75) {output = [245, 245, 245]}//'WhiteSmoke'}
		else if (elevation < 0.76) {output = [248, 248, 255]}//'GhostWhite'}
		else if (elevation < 0.9) {output = [255, 250, 250]}//'Snow'}
		else if (elevation <= 1) {output = [255, 255, 255]}//'White'}
	
	red = Math.round(output[0])
	green = Math.round(output[1])
	blue = Math.round(output[2])
	return `rgb(${red},${green},${blue}`	
	}

function gaussian(x, mu, sigma) {
	// Return f(x) for a given x value for a defined normal distribution
	// Distribution is scaled such that f(1) = 1 for mu=0, sigma=1
	fx = (1/(sigma*((2*Math.PI)**0.5)))*Math.exp(-0.5*(((x-mu)/sigma)**2))
	fmu = (1/(sigma*((2*Math.PI)**0.5)))*Math.exp(-0.5*(((mu-mu)/sigma)**2))
	fxscaled = fx/fmu
	return fxscaled
}

function dropOff(x, rate) {
	// Returns f(x) close to 1 for values close to 0 
	// (i.e. values with small distances to the centre), 
	// and then rapidly drops off
	//return -((1000000**(10**rate))**(x-1))+1
	logtenrate = Math.log(rate) / Math.log(10)
	fx = -((x/(10*(logtenrate)))**2)+1
	return fx
	}

function blur(y,x,array,amount) {
	// Will return the average of all the values in kernel of size 'amount' in a given 'array'
	let value = null;
	let sum = 0;
	let count = 0;
	let yoffmin = Math.floor(y-(amount/2));
	let yoffmax = Math.floor(y+(amount/2));
	let xoffmin  = Math.floor(x-(amount/2));
	let xoffmax = Math.floor(x+(amount/2));
	for (let yoffset = yoffmin; yoffset <= yoffmax+1; yoffset++) {
			for (let xoffset = xoffmin; xoffset <= xoffmax+1; xoffset++) {
				if ((xoffset >= 0) && (yoffset >= 0) && (xoffset < array[y].length) && (yoffset < array.length)) {
					sum += array[yoffset][xoffset];
					count += 1;
					}
				}
			}
	
	if (count == 0) {value = array[y][x]}
	else {value = sum/count}
	//if (x==48) {console.log(y,x,'ys',yoffmin,yoffmax,'xs',xoffmin,xoffmax,'val', value)};
	return value;
	}

function scaleOctaves(octaves, lengthy, lengthx) {
	// This part ensures octave steps don't exceed the array length
	if (lengthy < (2**octaves)/2) {
			while (lengthy < (2**octaves)/2) {
					octaves = octaves - 1
					}
			}
	if (lengthx < (2**octaves)/2) {
			while (lengthx < (2**octaves)/2) {
					octaves = octaves - 1
					}
			}
	return octaves
	}

function noiseGen(lengthy, lengthx, octaves, micronoise) {
	// Length should also be a power of 2
	// This part ensures octave steps don't exceed the array length
	octaves = scaleOctaves(octaves, lengthy, lengthx)
	
	// Find indices of array centre
	let ycentre = (lengthy-1)/2
	let xcentre = (lengthx-1)/2
	
	// Initialise seed array
	let randoms = [];
	for (let y = 0; y < lengthy; y++) {
		randoms.push([]);
		for (let x = 0; x < lengthx; x++) {
			randoms[y].push(Math.random());
			}
		}
	let drops = [];
	let combinationsum = 0;
	let octavesarray = [];
	let combined = [];
	let latitudes = [];
	for (let y = 0; y < lengthy; y++) {
		octavesarray.push([]);
		combined.push([]);
		drops.push([]);
		latitudes.push(gaussian(y/lengthy, 0.5, latitudesigma))
		for (let x = 0; x < lengthx; x++) {
			octavesarray[y].push([]);
			combined[y].push(0);
			drops[y].push([]);
			let combosum = 0
			for (let octave = 0; octave < octaves; octave++) {
				octavesarray[y][x].push([]);
				let steps = 2**octave;
				let stepsizey = Math.floor(lengthy/steps);
				let stepsizex = Math.floor(lengthy/steps);
				let y1 = Math.floor(y/stepsizex)*stepsizex;
				let x1 = Math.floor(x/stepsizex)*stepsizex;
				let y2 = null;
				let x2 = null;
				if (y1+stepsizey < lengthy) {
					y2 = y1+stepsizey;
					}
				else {
					y2 = 0;//y1
					}
				if (x1+stepsizex < lengthx) {
					x2 = x1+stepsizex;
					}
				else {
					x2 = 0;//x1
					}
				// For linear interpolation
				// Determine how far into the step this current coordinate is
				let stepdepthy = (y - y1)/stepsizey;
				let stepdepthx = (x - x1)/stepsizex;
				let value1 = (1 - stepdepthx)*randoms[y1][x1] + stepdepthx*randoms[y1][x2];
				let value2 = (1 - stepdepthx)*randoms[y2][x1] + stepdepthx*randoms[y2][x2];
				// If we're on the same y, just return the interpolated x value
				// Otherwise, return the interpolated y value between the two interpolated x values
				let valuefinal = stepdepthy * (value2-value1) + value1;
				
				// Combine octaves
				octavesarray[y][x][octave] = valuefinal;
				let gaussianfactor = gaussian(octave, combinationmu, combinationsigma);
				combined[y][x] += gaussianfactor*valuefinal;//(1/steps)
				combosum += gaussianfactor
				}
			
			// Normalise combined value, apply micronoise
			combined[y][x] = combined[y][x]/combosum;
			combined[y][x] = (1-micronoise)*combined[y][x] + micronoise*Math.random();
			
			// Apply edge drop off
			let distancefromcentre = ((((x-xcentre)/xcentre)**2) + (((y-ycentre)/ycentre)**2))**0.5;
			let proportionfromcentre = distancefromcentre
			let drop = dropOff(proportionfromcentre, edgedroprate);
			combined[y][x] = combined[y][x]*drop
			if (combined[y][x] < 0) {combined[y][x] = 0}
			drops[y][x] = drop
			if (drops[y][x] < 0) {drops[y][x] = 0}
			}
		}
	return [combined, drops, latitudes]
	}

let topography = null;
let drops = null;
let latitudes = null;
let watermap = [];
let moisturemap = [];

function startGame() {
	// Do all the initial creation
	output = noiseGen(objectsy, objectsx, octaves, micronoise);
	topography = output[0]
	drops = output[1]
	latitudes = output[2]
	for (let y = 0; y < objectsy; y++) {
		watermap[y] = topography[y].map(item => 0+(item <0.47));
		moisturemap[y] = []
		}
  for (let y = 0; y < objectsy; y++) {
		for (let x = 0; x < objectsx; x++) {
			moisturemap[y][x] = blur(y,x,watermap,moisturediffuseness)//watermap[y][x]
			points[y][x] = new component(pixelheight, pixelwidth, y, x, topography[y][x], moisturemap[y][x], latitudes[y]);
			}
		}
  myGameArea.start();
	}

let myGameArea = {
    canvas : document.createElement("canvas"),
    start : function() {
        this.canvas.width = docwidth;
        this.canvas.height = docheight;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.interval = setInterval(updateGameArea, 20);
    },
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}


function updateGameArea() {
	myGameArea.clear();
	for (let y = 0; y < objectsy; y++) {
		for (let x = 0; x < objectsx; x++) {
		points[y][x].update()
			}
		}
	}
</script>
</body>
</html>
