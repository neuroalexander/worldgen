<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    background-color: #f1f1f1;
    width: 100%;
    height: 100%;
}
</style>
</head>
<body onload="startGame()">
<script>

let	points = []
const objects = document.documentElement.clientHeight*document.documentElement.clientWidth/20 //Must be square number
const complexity = 12+Math.floor(Math.random()*13)
const smoothing = 3+Math.floor(Math.random()*8)
const startingoctave = Math.floor(Math.random()*4)
let octaveratio = 0.85+Math.random()*0.07 //Rate of octave change. Larger number -> less octave mixing effects
let metaoctaveratio = 0.3+Math.random()*0.1 //Rate of octaveratio change. Larger number -> less octave mixing effects
const elevationbias = Math.random()//0.0+ 0.5*0.5 + 0.5*(Math.random()-0.5)
const elevationbiasratio = Math.random() //How similar to the biased elevation the whole map should be;
const microvariancemax = 0.015+Math.random()*0.025 //0.05//Amount of random higher-octave change per octave combination. Larger number -> more change
const objectsx = Math.sqrt(objects)
const objectsy = Math.sqrt(objects)
const docheight = document.documentElement.clientHeight;
const docwidth = document.documentElement.clientWidth;
const pixelheight = docheight/objectsy
const pixelwidth = docwidth/objectsx

function colourGet(x,y,colourmap) {
	let colourvalue = colourmap[y][x]
	if (colourvalue < 0.36) {return 'Teal'}
	else if (colourvalue < 0.43) {return 'DarkCyan'}
	else if (colourvalue < 0.45) {return 'LightSeaGreen'}
	else if (colourvalue < 0.46) {return 'MediumAquaMarine'}
	else if (colourvalue < 0.48) {return 'Khaki'}
	else if (colourvalue < 0.52) {return 'DarkGreen'}
	else if (colourvalue < 0.56) {return 'Green'}
	else if (colourvalue < 0.62) {return 'ForestGreen'}
	else if (colourvalue < 0.66) {return 'OliveDrab'}
	else if (colourvalue < 0.69) {return 'DarkOliveGreen'}
	else if (colourvalue < 0.70) {return 'DarkGrey'}
	else if (colourvalue < 0.72) {return 'Silver'}
	else if (colourvalue < 0.73) {return 'LightGrey'}
	else if (colourvalue < 0.74) {return 'Gainsboro'}
	else if (colourvalue < 0.82) {return 'WhiteSmoke'}
	else if (colourvalue < 0.85) {return 'GhostWhite'}
	else if (colourvalue < 0.9) {return 'Snow'}
	else if (colourvalue <= 1) {return 'White'}
	}

function noisegen(xtotal,ytotal,octaves) {
	if (octaves < 2) {octaves = 2};
	let octavesarray = []; 
	for (let octave = 0; octave < octaves; octave++) {
		octavesarray.push([]);
		let seeds = [];
		for (let seedy = 0; seedy < octave+1; seedy++) {
			seeds.push([]);
			for (let seedx = 0; seedx < octave+1; seedx++) {
				seeds[seedy].push([]);
				seeds[seedy][seedx] = Math.random();
				}
			}
		for (let y = 0; y < ytotal; y++) {
			octavesarray[octave].push([]);
			for (let x = 0; x < xtotal; x++) {
				octavesarray[octave][y][x] = seeds[Math.floor((y/ytotal)*seeds.length)][Math.floor((x/xtotal)*seeds.length)];
				}
			}
	}
	// Blur each octave in octavesarray
	for (let octave = 0; octave < octavesarray.length; octave++) {
		for (let s = 1; s < smoothing/(octave+1); s++) {
			octavesarray[octave] = blur(octavesarray[octave])
			}
		}
	
	// Mix/combined each octave
	let octavecombination = [];
	for (let y = 0; y < ytotal; y++) {
		octavecombination.push([]);
		for (let x = 0; x < xtotal; x++) {
			octavecombination[y].push([])
			for (let octave = 0; octave < octavesarray.length; octave++) {
				let cumulativeoctiveratio = octaveratio
				let microvariance = Math.random()*microvariancemax
				if (octave < startingoctave) {}
				else if (octave == startingoctave) {
					octavecombination[y][x] = elevationbiasratio*elevationbias + (1-(elevationbiasratio*elevationbias))*octavesarray[octave][y][x]
					}
				else {
					cumulativeoctiveratio = octaveratio + metaoctaveratio*(1-octaveratio);
					octavecombination[y][x] = (cumulativeoctiveratio-microvariance)*octavecombination[y][x] + (1-cumulativeoctiveratio+microvariance)*octavesarray[octave][y][x];
					}
				}
			}
		}
	return octavecombination
}

function blur(array) {
let newarray = []
	for (let y = 0; y < array.length; y++) {
	newarray.push([])
		for (let x = 0; x < array[y].length; x++) {
		newarray[y].push([])
			if ((y-1 >= 0) && (x-1 >= 0) && (y+1 < array.length) && (x+1 < array[y].length)) {
				newarray[y][x] = (array[y-1][x-1] + array[y][x-1] + array[y+1][x-1] + array[y-1][x] + array[y][x] + array[y+1][x] + array[y-1][x+1] + array[y][x+1] + array[y+1][x+1])/9
				}
			else {
				newarray[y][x] = array[y][x]
				}
			}
		}
		return newarray
}

let topography = noisegen(objectsx,objectsy,complexity);
for (let s = 0; s < smoothing; s++) {
	topography = blur(topography);
	}

function startGame() {
		let i = 0
    for (let y = 0; y < objectsx; y++) {
			for (let x = 0; x < objectsx; x++) {
				points[i] = new component(pixelwidth, pixelheight, x, y,);
    		i += 1
				}
			}
    myGameArea.start();
	}

var myGameArea = {
    canvas : document.createElement("canvas"),
    start : function() {
        this.canvas.width = docwidth;
        this.canvas.height = docheight;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.interval = setInterval(updateGameArea, 20);
    },
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

function component(width, height, x, y) {
    this.width = width;
    this.height = height;
		this.x = x;
    this.y = y; 
    this.colour = colourGet(this.x,this.y,topography)
    this.update = function(){
        ctx = myGameArea.context;
        ctx.fillStyle = this.colour;
        ctx.fillRect(this.x*pixelwidth, this.y*pixelheight, this.width, this.height);
    }
}

let colourindex = 0
function updateGameArea() {
    myGameArea.clear();
    for (let i = 0; i < points.length; i++) {
      points[i].update();
    }
}
</script>
</body>
</html>
