<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    background-color: #f1f1f1;
    width: 100%;
    height: 100%;
}
</style>
</head>
<body onload="startGame()">
<script>

let	points = []
const octaves = 20
const micronoise = 0
const scale = 2
const docheight = document.documentElement.clientHeight;
const docwidth = document.documentElement.clientWidth;
let objectsy = docheight/scale
let objectsx = docheight/scale
const pixelheight = Math.round(docheight/objectsy)
const pixelwidth = Math.round(docwidth/objectsx)

function colourGet(y,x,colourmap) {
	let colourvalue = colourmap[y][x];
		if (colourvalue < 0.36) {return 'Teal'}
		else if (colourvalue < 0.43) {return 'DarkCyan'}
		else if (colourvalue < 0.45) {return 'LightSeaGreen'}
		else if (colourvalue < 0.46) {return 'MediumAquaMarine'}
		else if (colourvalue < 0.48) {return 'Khaki'}
		else if (colourvalue < 0.52) {return 'DarkGreen'}
		else if (colourvalue < 0.56) {return 'Green'}
		else if (colourvalue < 0.62) {return 'ForestGreen'}
		else if (colourvalue < 0.66) {return 'OliveDrab'}
		else if (colourvalue < 0.69) {return 'DarkOliveGreen'}
		//else if (colourvalue < 0.76) {return 'DarkGrey'}
		else if (colourvalue < 0.74) {return 'DimGrey'}
		//else if (colourvalue < 0.78) {return 'Silver'}
		//else if (colourvalue < 0.79) {return 'LightGrey'}
		else if (colourvalue < 0.76) {return 'Gainsboro'}
		else if (colourvalue < 0.77) {return 'WhiteSmoke'}
		else if (colourvalue < 0.78) {return 'GhostWhite'}
		else if (colourvalue < 0.9) {return 'Snow'}
		else if (colourvalue <= 1) {return 'White'}
	}

function noisegen(lengthy, lengthx, octaves, micronoise) {
	// Length should also be a power of 2
	// This part ensures octave steps don't exceed the array length
	if (lengthy < (2**octaves)/2) {
			while (lengthy < (2**octaves)/2) {
					octaves = octaves - 1
					}
			}
	if (lengthx < (2**octaves)/2) {
			while (lengthx < (2**octaves)/2) {
					octaves = octaves - 1
					}
			}

	// Initialise seed array
	let randoms = [];
	for (let y = 0; y < lengthy; y++) {
		randoms.push([]);
		for (let x = 0; x < lengthx; x++) {
			randoms[y].push(Math.random());
			}
		}

	let combinationsum = 0;
	let octavesarray = [];
	let combined = [];
	for (let y = 0; y < lengthy; y++) {
		octavesarray.push([]);
		combined.push([]);
		for (let x = 0; x < lengthx; x++) {
			octavesarray[y].push([]);
			combined[y].push(0);
			let combosum = 0
			for (let octave = 0; octave < octaves; octave++) {
				octavesarray[y][x].push([]);
				let steps = 2**octave;
				let stepsizey = Math.floor(lengthy/steps);
				let stepsizex = Math.floor(lengthy/steps);
				let y1 = Math.floor(y/stepsizex)*stepsizex;
				let x1 = Math.floor(x/stepsizex)*stepsizex;
				let y2 = null;
				let x2 = null;
				if (y1+stepsizey < lengthy) {
					y2 = y1+stepsizey;
					}
				else {
					y2 = y1;
					}
				if (x1+stepsizex < lengthx) {
					x2 = x1+stepsizex;
					}
				else {
					x2 = x1;
					}
				// For linear interpolation
				// Determine how far into the step this current coordinate is
				let stepdepthy = (y - y1)/stepsizey;
				let stepdepthx = (x - x1)/stepsizex;
				let value1 = (1 - stepdepthx)*randoms[y1][x1] + stepdepthx*randoms[y1][x2];
				let value2 = (1 - stepdepthx)*randoms[y2][x1] + stepdepthx*randoms[y2][x2];
				// If we're on the same y, just return the interpolated x value
				// Otherwise, return the interpolated y value between the two interpolated x values
				let valuefinal = stepdepthy * (value2-value1) + value1;
				
				octavesarray[y][x][octave] = valuefinal;
				combined[y][x] += (1/steps)*valuefinal;
				combosum += (1/steps)
				}
			combined[y][x] = combined[y][x]/combosum;
			combined[y][x] = (1-micronoise)*combined[y][x] + micronoise*Math.random();
			
			}
		}
	return combined
	}

let topography = null;
function startGame() {
	topography = noisegen(objectsy, objectsx, octaves, micronoise);
	let i = 0
  for (let y = 0; y < objectsy; y++) {
		for (let x = 0; x < objectsx; x++) {
			points[i] = new component(pixelheight, pixelwidth, y, x,);
    	i += 1
			}
		}
  myGameArea.start();
	}

let myGameArea = {
    canvas : document.createElement("canvas"),
    start : function() {
        this.canvas.width = docwidth;
        this.canvas.height = docheight;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.interval = setInterval(updateGameArea, 100);
    },
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

function component(height, width, y, x) {
    this.width = width;
    this.height = height;
		this.x = x;
    this.y = y; 
    this.colour = colourGet(this.y,this.x,topography)
    this.update = function(){
        ctx = myGameArea.context;
        ctx.fillStyle = this.colour;
        ctx.fillRect(this.x*pixelwidth, this.y*pixelheight, this.width, this.height);
    }
}

function updateGameArea() {
    myGameArea.clear();
    for (let i = 0; i < points.length; i++) {
      points[i].update();
    }
}
</script>
</body>
</html>
